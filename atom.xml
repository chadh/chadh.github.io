<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Blog]]></title>
  <link href="http://chadh.github.io/atom.xml" rel="self"/>
  <link href="http://chadh.github.io/"/>
  <updated>2013-10-18T19:31:33-04:00</updated>
  <id>http://chadh.github.io/</id>
  <author>
    <name><![CDATA[Chad Huneycutt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CoreOS]]></title>
    <link href="http://chadh.github.io/blog/2013/10/18/coreos/"/>
    <updated>2013-10-18T17:46:00-04:00</updated>
    <id>http://chadh.github.io/blog/2013/10/18/coreos</id>
    <content type="html"><![CDATA[<p>I wrote about <a href="http://chadh.github.io/blog/2013/10/17/docker/">Docker</a> yesterday and teased that today I would discuss <a href="http://coreos.com">CoreOS</a>.  I came across CoreOS indirectly through a tweet about Kelsey Hightower&rsquo;s <a href="https://github.com/kelseyhightower/confd">confd</a>.  I will not go into confd, right now (have not really looked into it anyway), but it works with <a href="https://github.com/coreos/etcd">etcd</a>, which is one of features of CoreOS.</p>

<p>So what is CoreOS?</p>

<p>As its name suggests, it is a minimal OS.  It is based on the linux kernel and features <a href="http://www.freedesktop.org/wiki/Software/systemd/">systemd</a>, etcd, and docker.  It is essentially a hypervisor for containers.  There is no package manager as there is no software to manage.  Upgrades to the OS occur as atomic system updates, requiring a reboot to take effect.  I expounded at length about Docker&rsquo;s notion of containerized services, and CoreOS takes that to its logical conclusion: nothing runs directly on the host OS.</p>

<p>Whether or not CoreOS or something like it is the future of system provisioning, it provides a very easy to use platform for taking Docker for a spin.  I was able to easily bring up a vagrant box with CoreOS and start playing with Docker.  With a little more effort, Docker also works with Ubuntu 12.04 or later (with updated 3.8 kernel), but why bother with all the overhead?</p>

<p>Here&rsquo;s a session to show an Ubuntu container running inside CoreOS running inside Vagrant:</p>

<figure class='code'><figcaption><span>Vagrant/CoreOS Bash Session </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ch145@strangepork:~/coreos-vagrant (master)$ grep DISTRIB /etc/lsb-release 
</span><span class='line'>DISTRIB_ID=Ubuntu
</span><span class='line'>DISTRIB_RELEASE=12.04
</span><span class='line'>DISTRIB_CODENAME=precise
</span><span class='line'>DISTRIB_DESCRIPTION="Ubuntu 12.04.3 LTS"
</span><span class='line'>ch145@strangepork:~/coreos-vagrant (master)$ vagrant ssh
</span><span class='line'>Last login: Fri Oct 18 23:06:44 UTC 2013 from 10.0.2.2 on ssh
</span><span class='line'>   ______                ____  _____
</span><span class='line'>  / ____/___  ________  / __ \/ ___/
</span><span class='line'> / /   / __ \/ ___/ _ \/ / / /\__ \
</span><span class='line'>/ /___/ /_/ / /  /  __/ /_/ /___/ /
</span><span class='line'>\____/\____/_/   \___/\____//____/
</span><span class='line'>core@localhost ~ $ 
</span><span class='line'>
</span><span class='line'>core@localhost ~ $ grep DISTRIB /etc/lsb-release 
</span><span class='line'>DISTRIB_ID=CoreOS
</span><span class='line'>DISTRIB_RELEASE=106.0.0
</span><span class='line'>DISTRIB_CODENAME="West Coast Style"
</span><span class='line'>DISTRIB_DESCRIPTION="CoreOS 106.0.0 (Official Build) dev-channel amd64-generic test"
</span><span class='line'>core@localhost ~ $ docker run -t -i ubuntu grep DISTRIB /etc/lsb-release
</span><span class='line'>DISTRIB_ID=Ubuntu
</span><span class='line'>DISTRIB_RELEASE=12.04
</span><span class='line'>DISTRIB_CODENAME=precise
</span><span class='line'>DISTRIB_DESCRIPTION="Ubuntu 12.04 LTS"</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker]]></title>
    <link href="http://chadh.github.io/blog/2013/10/17/docker/"/>
    <updated>2013-10-17T20:04:00-04:00</updated>
    <id>http://chadh.github.io/blog/2013/10/17/docker</id>
    <content type="html"><![CDATA[<p>While at DevOps Days Atlanta a couple weeks ago, I was introduced to <a href="https://www.docker.io">Docker</a>, which is tool for managing <a href="http://lxc.sf.net">lxc linux containers</a>.  It was some really powerful features that are changing the way some people provide services and doing Infrastructure CI.</p>

<!--more-->


<p> Ever since I saw a presentation on Solaris zones, I have wanted to play with containers in linux, but when I tried <a href="http://openvz.org">OpenVZ</a>, it was pretty heavy-weight &mdash; required a custom kernel, and there was a lot of manual configuration to get it all going.  I never got to play with <a href="http://linux-vserver.org">Linux-Vserver</a>), but I take it that the same thing applied there.  Those two projects have been around quite a while, and they are apparently still the right way to do &ldquo;real&rdquo; containerization with all the security implications that arise when allowing users privileged-level access to the containers.</p>

<p>Over the last few years, the various container projects have slowly been getting parts of their kernel modifications into the mainline kernel, and with the recent finalization of user namespaces, apparently kernel support has hit critical mass.  There has been a lot of movement with lxc in the last month or two, and Docker seems to be attracting a lot of attention.</p>

<p>Docker has two particularly neat use cases: <em>scriptability</em> and <em>service isolation</em>.  The former is pretty standard for the seemingly never ending parade of continuous integration tools that are so popular these days.  Using a <code>Dockerfile</code> (compare to <code>Vagrantfile</code>, <code>Puppetfile</code>, etc.), one can specify a sequence of directives to build, unpack, create, and customize a container.  The end result is very similar to spinning up a vagrant box, except it is much faster.  There is no booting overhead &mdash; just unpack a filesystem, and the container is ready.  Furthermore, Docker caches each step of the process (like with a <code>Makefile</code>), so the next time you create the container, it is essentially instantaneous.</p>

<p>The other use case for which Docker is really known is service isolation.  That is, they encourage creating a container per service.  For instance, if your application stack requires a web server, message broker, and database, create three separate containers.  While this strategy might add some processing overhead, it can greatly reduce the configuration overhead.  Frequently the different parts of a software stack have very specific requirements.  As an example, puppet and foreman are both ruby web applications.   There have been times when I wanted to (or maybe had to) use different versions of ruby for each.  That is possible to do in a single deployment, but it is relatively complictated to set up.  With containers, puppet would run in a container, foreman would run in another, and they each could have their own ruby stack.  There is another advantage if you are running applications that are picky about what port on which they listen.  Docker can map the container port to a different host port.</p>

<p>I think what really draws me to those particular features is that they address two of my biggest time sinks.  I spend <strong>a lot</strong> of time waiting for VMs to spin up and then software to install when testing provisioning scripts.  Spinning up a container is really fast; the timings I have seen online are sub-second after the first time.  I also spend far too long trying to integrate the new hotness into my environment.  With containers, if the software author wrote his installation process for ubuntu 12.04, I can just use a 12.04 container.  If the developer only supports Red Hat, I can do that too.</p>

<p>Wow, this was really long, and that was just one part of the discussion.  The obvious use case for this in my environment is the example I used.  I plan to refactor the puppet master deployment to use Docker for managing puppet master, puppet db, and foreman containers.  Next time I&rsquo;ll talk about <a href="http://coreos.com">coreos</a> as the base for running Docker.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Post]]></title>
    <link href="http://chadh.github.io/blog/2013/10/17/first-post/"/>
    <updated>2013-10-17T19:56:00-04:00</updated>
    <id>http://chadh.github.io/blog/2013/10/17/first-post</id>
    <content type="html"><![CDATA[<p>Not sure if I will stick with this, but I&rsquo;m trying out a blog on github pages.  I like the idea of having my entries in human readable files, checked into git, but I am not sure if markdown is going to be expressive enough for me.</p>
]]></content>
  </entry>
  
</feed>
